<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<title>Лабораторная работа 3</title>

	<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/5.0.0-alpha2/css/bootstrap.min.css" integrity="sha384-DhY6onE6f3zzKbjUPRc2hOzGAdEf4/Dz+WJwBvEYL/lkkIsI3ihufq9hk9K4lVoK" crossorigin="anonymous">

	<link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
	<link rel="stylesheet" type="text/css" href="../sources/css/normalize.css">
	<link rel="stylesheet" type="text/css" href="../sources/css/main.css">
	<link rel="stylesheet" type="text/css" href="../sources/css/tables.css">
	<link rel="stylesheet" type="text/css" href="../sources/css/tabs.css">
	<link rel="stylesheet" type="text/css" href="../sources/css/component.css">
	<link rel="stylesheet" type="text/css" href="../sources/css/example.css">

	<link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Cardo" rel="stylesheet">

	<script src="../sources/js/modernizr.custom.js"></script>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

	<style>
		canvas#canvas {
			background-color: #1C1E20;
			border-radius: 20px;
			margin: 20px auto 0px;
			max-width: 80%;	
		}
	</style>
</head>
<body>
	<div class="box">
		<ul id="gn-menu" class="gn-menu-main">
			<li class="gn-trigger">
				<a class="gn-icon gn-icon-menu"><span>Menu</span></a>
				<nav class="gn-menu-wrapper">
					<div class="tabs">
						<input type="radio" name="tab-btn" id="tab-btn-1" value="" checked>
						<label for="tab-btn-1">Меню</label>
						<input type="radio" name="tab-btn" id="tab-btn-2" value="">
						<label for="tab-btn-2">Лабы</label>

						<div id="content-1">
							<div class="gn-scroller">
								<ul class="gn-menu">
									<li><a href="#header"><span>1</span>Цвета</a>
									<li><a href="#M2"><span>2</span>Прозрачность</a>
									<li><a href="#M3"><span>3</span>Стили линий</a>
									<li><a href="#M4"><span>4</span>Использование штрихов</a>
									<li><a href="#M5"><span>5</span>Градиенты</a>
									<li><a href="#M6"><span>6</span>Шаблоны</a>
									<li><a href="#practic"><span>-</span>Практика</a>
									
								</ul>
							</div>
						</div>

						<div id="content-2">
							<div class="gn-scroller">
								<ul class="gn-menu">
									<li><a href="lab_1.html"><span>1</span>Основы canvas</a></li>
									<li><a href="lab_2.html"><span>2</span>Создание различных фигур</a></li>
									<li><a href="lab_3.html"><span>3</span>Стили и цвета</a></li>
									<li><a href="lab_4.html"><span>4</span>Изображения и текст</a></li>
									<li><a href="lab_5.html"><span>5</span>Трансформации</a></li>
									<li><a href="lab_6.html"><span>6</span>Анимации</a></li>
								</ul>
							</div>
						</div>
					</div>
					<!-- /gn-scroller -->
				</nav>
			</li>

			<div class="container-fluid">
				<div class="row justify-content-end">
					<div class="col-12 col-sm-auto ml-sm-auto"><img class="logo" src="../sources/images/logo.png"></div>
					<div class="col-1 col-sm-auto ml-sm-auto d-none d-sm-block"><a href="#header" class="up"><i class="fa fa-chevron-circle-up" aria-hidden="true"></i> Вверх</a></div>
				</div>
			</div>
		</ul>

		<header id="header">
			<h1>Лабораторная работа 3<span>Изучение кастомизации фигур на полотне, работа с цветом</span></h1>
		</header>
	</div><!-- /box -->

	<div class="container">
		<div class="row">
			<div class="content col-12">

				<div><h2 class="section" id="M1">1. Цвета</h2></div>

				<p>В лабораторной работе о рисовании фигур, использовали для линий и заполнения только стили по умолчанию. Здесь будем исследовать опции <code>canvas</code>, которые имеем в нашем распоряжении, чтобы сделать наши рисунки немного более привлекательными. Вы узнаете, как добавлять различные цвета, стили линий, градиенты, узоры и тени вашим рисункам.</p>

				<div class="center"><iframe src="../sources/examples/frames/l3_main_canvas.html" class="iframemain"></iframe></div>
				
				<p class="cuptionexample">Демонстрация возможностей canvas.</p>
				
				<p>До сих пор видели только методы рисования контекста. Если хотим применить цвета к фигуре, то есть два важных свойства, которые можем использовать: <code>fillStyle</code> и <code>strokeStyle</code>.</p>
				<p><code>fillStyle = color</code> - Устанавливает стиль для фона фигур.</p>
				<p><code>strokeStyle = color</code> - Устанавливает стиль контура фигуры.</p>
				<p><code>color</code> может быть цветом, (строка, представленная в CSS <code>&lt;color&gt;</code>), градиентом или паттерном. Градиенты и паттерны рассмотрим позже. По умолчанию цвет фона и контура  — черный (значение CSS цвета  <code>#000000</code>).</p>
				<p class="note">Когда вы устанавливаете  значения <code>strokeStyle</code> и/или <code>fillStyle</code>, то новое значение становится стандартным для всех фигур, которые будут нарисованы с этого момента. Когда вам нужен другой цвет, вы должны перезаписать значение в <code>fillStyle</code> или в <code>strokeStyle</code> для каждой фигуры.</p>
				<p>Чтобы строка <code>color</code> считалась валидной, она должна соответствовать CSS <code>&lt;color&gt;</code>. Далее приведены примеры того, как можно по-разному задать один и тот же цвет. </p>
				<p class="code">
					// these all set the fillStyle to 'orange' <br>
					 <br>
					ctx.fillStyle = "orange"; <br>
					ctx.fillStyle = "#FFA500"; <br>
					ctx.fillStyle = "rgb(255,165,0)"; <br>
					ctx.fillStyle = "rgba(255,165,0,1)";
				</p>

				<div><h2 class="section" id="M2">2. Прозрачность</h2></div>

				<p>В дополнении к рисованию непрозрачных фигур, также можем рисовать прозрачные (полупрозрачные) фигуры.  Это делается через установку свойства <code>globalAlpha</code> или задачи полупрозрачного цвета фона или контура.</p>
				<p><code>globalAlpha = transparencyValue</code> - Для применения, указывается значения прозрачности для всех будущих фигур, что будут нарисованы на canvas. Значение полупрозрачности могут быть между 0.0 (полная прозрачность) и 1.0 (полная непрозрачность). Значение 1.0 (полная непрозрачность) установлено по умолчанию.</p>
				<p>Свойство <code>globalAlpha</code> может быть использовано, если вы хотите рисовать формы с одинаковой прозрачностью, но в иной ситуации, обычно устанавливают прозрачность индивидуально к каждой форме, когда указывают их цвет.</p>
				<p>Так как свойства <code>strokeStyle</code> и <code>fillStyle</code> принимают цветовые значения <code>rgba</code> через CSS, можем использовать следующее обозначение  для назначения прозрачных цветов.</p>
				<p class="code">
					// Assigning transparent colors to stroke and fill style <br>
					 <br>
					ctx.strokeStyle = "rgba(255,0,0,0.5)"; <br>
					ctx.fillStyle = "rgba(255,0,0,0.5)";
				</p>
				<p>Функция <code>rgba()</code> похожа на функцию <code>rgb()</code>, но имеет один дополнительный параметр. Последний параметр устанавливает значение прозрачности для конкретного цвета. Действующий диапозон значений находится между 0.0 (полная прозрачность) и 1.0 (полная непрозрачность).</p>
				<p>В примере ниже нарисуем фон и четыре квадрата с различными цветами.  Сверху изображения будет выведен набор полупрозрачных кругов. Установим свойство <code>globalAlpha</code> значением 0.2, которое будет использовано для всех последующих форм. Каждый шаг цикла рисует круг с большим радиусом. По окончанию получим радиальный градиент. Накладывая еще больше кругов друг на друга, фактически сможем уменьшить прозрачность ранее нарисованных кругов. Увеличив счетчик итераций, при этом рисуя еще круги, сможем добиться исчезновение центра изображения.</p>
				<p class="code">
					// фон изображения <br>
					ctx.fillStyle = '#FD0'; <br>
					ctx.fillRect(0,0,75,75); <br>
					ctx.fillStyle = '#6C0'; <br>
					ctx.fillRect(75,0,75,75); <br>
					ctx.fillStyle = '#09F'; <br>
					ctx.fillRect(0,75,75,75); <br>
					ctx.fillStyle = '#F30'; <br>
					ctx.fillRect(75,75,75,75); <br>
					ctx.fillStyle = '#FFF'; <br>
 					<br>
					// устанавливаем значение прозрачности <br>
					ctx.globalAlpha = 0.2; <br>
 					<br>
					// Рисуем полупрозрачные круги <br>
					for (i=0;i<7;i++){ <br>
					ctx.beginPath(); <br>
					ctx.arc(75,75,10+10*i,0,Math.PI*2,true); <br>
					ctx.fill(); <br>
					} <br>
					}
				</p>
				<img src="../sources/examples/pic/windowslogo.png" alt="" class="center">
				<p>В этом втором примере делаем что-то похожее на предыдущее, но вместо рисования кругов друг над другом, нарисованы маленькие прямоугольники с увеличением непрозрачности. Использование <code>rgba()</code> добавляет контроля и гибкости, поскольку можем индивидуально настраивать стиль заливки и штриха.</p>
				<p class="code">
					// Нарисовать фон <br>
					ctx.fillStyle = 'rgb(255,221,0)'; <br>
					ctx.fillRect(0,0,150,37.5); <br>
					ctx.fillStyle = 'rgb(102,204,0)'; <br>
					ctx.fillRect(0,37.5,150,37.5); <br>
					ctx.fillStyle = 'rgb(0,153,255)'; <br>
					ctx.fillRect(0,75,150,37.5); <br>
					ctx.fillStyle = 'rgb(255,51,0)'; <br>
					ctx.fillRect(0,112.5,150,37.5); <br>
					 <br>
					// Нарисовать полупрозрачные прямоугольники <br>
					for (var i=0;i<10;i++){ <br>
					ctx.fillStyle = 'rgba(255,255,255,'+(i+1)/10+')'; <br>
					for (var j=0;j<4;j++){ <br>
					ctx.fillRect(5+i*14,5+j*37.5,14,27.5); <br>
					} <br>
					} <br>
				</p>
				<img src="../sources/examples/pic/rgba_example.png" alt="" class="center">

				<div><h2 class="section" id="M3">3. Стили линий</h2></div>

				<p>Есть несколько свойств, которые позволяют нам стилизовать линии.</p>
				<ul>
					<li><code>lineWidth = value</code> - Устанавливает ширину линий, рисуемых в будущем.</li>
					<li><code>lineCap = type</code> - Устанавливает внешний вид концов линий.</li>
					<li><code>lineJoin = type</code> - Устанавливает внешний вид «углов», где встречаются линии.</li>
					<li><code>miterLimit = value</code> - Устанавливает ограничение на митру, когда две линии соединяются под острым углом, чтобы вы могли контролировать её толщину.</li>
					<li><code>getLineDash()</code> - Возвращает текущий массив тире штриховки, содержащий четное число неотрицательных чисел.</li>
					<li><code>setLineDash(segments)</code> - Устанавливает текущий пунктир линии.</li>
					<li><code>lineDashOffset = value</code> - Указывает, где следует начинать тире массива в строке.</li>
				</ul>
				<p><code>lineWidth</code> - Это свойство задает толщину текущей строки. Значения должны быть положительными. По умолчанию для этого значения установлено 1.0 единицы.</p>
				<p>Ширина линии - это толщина хода, центрированного по данному пути. Другими словами, область, которая нарисована, простирается до половины ширины линии по обе стороны пути. Поскольку координаты холста не напрямую ссылаются на пиксели, особое внимание следует уделять получению четких горизонтальных и вертикальных линий.</p>
				<p>В приведенном ниже примере 10 прямых линий рисуются с увеличением ширины линий. Линия в крайнем левом углу - 1.0 единицы. Тем не менее, толщина левой и всех других линий нечетной ширины не выглядят четкими из-за позиционирования пути.</p>
				<p class="code">
					var ctx = document.getElementById('canvas').getContext('2d'); <br>
					for (var i = 0; i < 10; i++){ <br>
					ctx.lineWidth = 1+i; <br>
					ctx.beginPath(); <br>
					ctx.moveTo(5+i*14,5); <br>
					ctx.lineTo(5+i*14,140); <br>
					ctx.stroke(); <br>
					}
				</p>
				<img src="../sources/examples/pic/linewidth.png" alt="" class="center">
				<p>Получение четких строк требует понимания путей сглаживания. На рисунках ниже представлена сетка координат холста. Квадраты между сетками являются фактическими экранными пикселями. В первом изображении сетки ниже прямоугольник от (2, 1) до (5, 5) заполняется. Вся область между ними (светло-красный) падает на границы пикселей, поэтому полученный заполненный прямоугольник будет иметь четкие края.</p>
				<div class="center">
					<img src="../sources/examples/pic/canvas-grid.png" alt="" class="center">
				</div>
				<p>Если вы рассмотрите путь от (3, 1) до (3, 5) с толщиной строки 1.0, вы получите ситуацию во втором изображении. Фактическая заполняемая область, (синяя), распространяется только наполовину в пикселях по обе стороны пути. Приблизительно это означает, что частично затенённые пиксели приводят к заполнению всей области (светло-голубой и синей) цветом, только наполовину темным, чем фактический цвет штриха. Это то, что происходит с линией шириной 1.0 в предыдущем примере кода.</p>
				<p>Чтобы исправить это, вы должны быть более точными при создании пути. Зная, что линия шириной 1.0 занимает половину единицы по обе стороны пути, создание пути от (3.5, 1) до (3.5, 5) приведёт к ситуации в третьем изображении - ширина линии 1.0 закончится верно, точно заполняя вертикальную линию с одним пикселем.</p>
				<p class="note">Имейте в виду, что в примере с вертикальной линией позиция <code>Y</code> по-прежнему ссылается на целочисленную позицию сетки - иначе увидели бы пиксели с половинным охватом в конечных точках (также обратите внимание, что это поведение зависит от текущего стиля <code>lineCap</code>,  значение по умолчанию - <code>butt</code>; вы можете вычислить согласованные штрихи с полупиксельными координатами для линий с нечетной шириной, установив стиль <code>lineCap</code> в <code>square</code>, чтобы внешняя граница вокруг конечной точки линии автоматически расширялась, охватывая весь пиксель в точку). Также обратите внимание, что затронуты только начальные и конечные  точки пути: если путь закрыт с помощью <code>closePath()</code>, - нет начальной и конечной точки; вместо этого все конечные точки в пути подключены к их прикрепленному предыдущему и следующему сегментам и при текущей настройке стиля <code>lineJoin</code> в значении по умолчанию - <code>miter</code>, с эффектом автоматического расширения внешних границ подключенных сегментов до их точки пересечения - обработанный ход будет точно покрывать полные пиксели с центром в каждой конечной точке, если эти связанные сегменты горизонтальны и/или вертикальны).</p>
				<p>Для линий с четной шириной каждая половина заканчивается как целое количество пикселей, поэтому вам нужен путь, который находится между пикселями (то есть (3,1) - (3,5)), вместо середины пикселей.</p>
				<p>Хотя это и необычно, когда изначально работаешь с масштабируемой 2D-графикой, обращая внимание на сетку пикселей и положение путей, но вы убедитесь, что ваши рисунки будут выглядеть правильно, независимо от масштабирования или любых других преобразований. Вертикальная линия ширины 1,0, построенная таким образом, станет четкой 2-пиксельной линией при увеличении на 2 и появится в правильном положении.</p>
				<p class="subsection">Пример <code>lineJoin</code></p>
				<p>Свойство <code>lineJoin</code> определяет, как соединяются два сегмента (линий, дуг или кривых) с ненулевой длиной в форме (вырожденные сегменты с нулевой длиной, заданные конечные точки и контрольные точки находятся точно в том же положении - пропущены).</p>
				<p>Для этого свойства есть три возможных значения: <code>round</code>, <code>bevel</code> и <code>miter</code>. По умолчанию для этого свойства установлено значение <code>miter</code>. Обратите внимание, что настройка <code>lineJoin</code> не действует, если два связанных сегмента имеют одно и то же направление, потому что в этом случае не будет добавлена ​​область соединения.</p>
				<ul>
					<li><code>round</code> - Радиус заполняемой части для скругленных углов равен половине ширины линии. центр этого радиуса совпадает с концами подключенных сегментов.</li>
					<li><code>bevel</code> - Заполняет дополнительную треугольную область между общей конечной точкой подключенных сегментов и отдельными внешними прямоугольными углами каждого сегмента.</li>
					<li><code>miter</code> - Подключенные сегменты соединяются путем расширения их внешних краев для соединения в одной точке с эффектом заполнения дополнительной области в форме пастилки. Эта настройка выполняется с помощью свойства miterLimit, которое объясняется ниже.</li>
				</ul>
				<p>В приведенном ниже примере показаны три разных пути, демонстрирующие каждый из этих трех свойств <code>lineJoin</code>; результат - выше. </p>
				<p class="code">
					var lineJoin = ['round','bevel','miter']; <br>
					ctx.lineWidth = 10; <br>
					for (var i=0;i&lt;lineJoin.length;i++){ <br>
					ctx.lineJoin = lineJoin[i]; <br>
					ctx.beginPath(); <br>
					ctx.moveTo(-5,5+i*40); <br>
					ctx.lineTo(35,45+i*40); <br>
					ctx.lineTo(75,5+i*40); <br>
					ctx.lineTo(115,45+i*40); <br>
					ctx.lineTo(155,5+i*40); <br>
					ctx.stroke(); <br>
					}
				</p>
				<img src="../sources/examples/pic/linejoin.png" alt="" class="center">

				<p class="subsection">Демонстрация свойства <code>miterLimit</code></p>
				<p>Как вы видели в предыдущем примере, при объединении двух строк с опцией <code>miter</code> внешние края двух соединительных линий расширены до точки, где они встречаются. Для линий, которые находятся под большими углами друг с другом, эта точка находится недалеко от внутренней точки соединения. Однако, поскольку углы между каждой линией уменьшаются, расстояние (длина меча) между этими точками увеличивается экспоненциально.</p>
				<p>Свойство <code>miterLimit</code> определяет, как далеко можно установить внешнюю точку соединения из внутренней точки подключения. Если две линии превышают это значение, вместо этого получается привязка конуса. Обратите внимание, что максимальная длина митра является произведением ширины линии, измеренной в текущей системе координат, значением этого свойства <code>miterLimit</code> (значение по умолчанию 10,0 в HTML <code>&lt;canvas&gt;</code>), поэтому <code>miterLimit</code> может устанавливаться независимо от текущей шкалы дисплея или любых аффинных преобразований путей: она влияет только на эффективно визуализированную форму ребер линии.</p>
				<p>Точнее, предел митры является максимально допустимым отношением длины расширения (в холсте HTML он измеряется между внешним углом соединенных краев линии и общей конечной точкой соединительных сегментов, указанными на пути), до половины ширины линии. Его можно равнозначно определить как максимально допустимое отношение расстояния между внутренней и внешней точками перехода краев к общей ширине линии. Затем он равен косекансу с половиной минимального внутреннего угла соединительных сегментов, ниже которого не будет создано ни одного соединения митра, а только скос соединяется:</p>
				<ul>
					<li><code>miterLimit = max miterLength / lineWidth = 1 / sin ( min θ / 2 )</code></li>
					<li>Предел митры по умолчанию, равный 10,0, разделит все митры углов, острее примерно 11 градусов.</li>
					<li>Предел митры, равный √2 ≈ 1.4142136 (rounded up) сгладит миты для всех острых углов, поддерживая митры только для тупых или прямых углов.</li>
					<li>Предел митры, равный 1,0, действителен, но отключит все миты.</li>
					<li>Значения ниже 1.0 являются недопустимыми для предела митры.</li>
				</ul>
				<p>Вот небольшая демонстрация, в которой вы можете динамически установить <code>miterLimit</code> и посмотреть, как это влияет на фигуры на холсте. Синие линии показывают, где начальная и конечная точки для каждой из линий в шаблоне зигзага.</p>
				<p>Если вы укажете в этой демонстрации значение <code>miterLimit</code> ниже 4.2, ни один из видимых углов не присоединится к расширению митры, но только с небольшим скосом рядом с синими линиями; с отметкой <code>miterLimit</code> выше 10, большинство углов в этой демонстрации должны соединяться с митрой, удаленной от синих линий, высота которой уменьшается между углами слева направо, потому что они соединяются с растущими углами; с промежуточными значениями углы с левой стороны будут соединяться только с скосом рядом с синими линиями, а углы с правой стороны с удлинителем митры (также с уменьшающейся высотой).</p>
				<p class="code">
					// Clear canvas <br>
					ctx.clearRect(0,0,150,150); <br>
					<br>
					// Draw guides<br>
					ctx.strokeStyle = '#09f'; <br>
					ctx.lineWidth   = 2;<br>
					ctx.strokeRect(-5,50,160,50); <br>
					<br>
					// Set line styles<br>
					ctx.strokeStyle = '#000'; <br>
					ctx.lineWidth = 10; <br>
					<br>
					// check input<br>
					if (document.getElementById('miterLimit').value.match(/\d+(\.\d+)?/)) { <br>
					ctx.miterLimit = parseFloat(document.getElementById('miterLimit').value); <br>
					} else {<br>
					alert('Value must be a positive number'); <br>
					} <br>
					<br>
					// Draw lines <br>
					ctx.beginPath();<br>
					ctx.moveTo(0,100);<br>
					for (i=0;i<24;i++){ <br>
					var dy = i%2==0 ? 25 : -25 ;<br>
					ctx.lineTo(Math.pow(i,1.5)*2,75+dy);<br>
					} <br>
					ctx.stroke(); <br>
					return false;
				</p>
				<img src="../sources/examples/pic/miterlimit.png" alt="" class="center">

				<div><h2 class="section" id="M4">4. Использование штрихов</h2></div>

				<p>Метод <code>setLineDash</code> и свойство <code>lineDashOffset</code> задают шаблон штрихов для линий. Метод <code>setLineDash</code> принимает список чисел, который определяет расстояния для попеременного рисования линии и разрыва, а свойство <code>lineDashOffset</code> устанавливает смещение, с которого начинается шаблон.</p>
				<p>В этом примере создаем эффект походных муравьев. Это техника анимации, часто встречающаяся в инструментах выбора программ компьютерной графики. Это помогает пользователю отличить границу выделения от фона изображения, анимируя границу. В следующей части этого руководства вы узнаете, как сделать эту и другие основные анимации.</p>
				<p class="code">
					var ctx = document.getElementById('canvas').getContext('2d');  <br>
					var offset = 0;  <br>
					 <br>
					function draw() {  <br>
					ctx.clearRect(0,0, canvas.width, canvas.height); <br>
					ctx.setLineDash([4, 2]); <br>
					ctx.lineDashOffset = -offset;  <br>
					ctx.strokeRect(10,10, 100, 100); <br>
					}  <br>
					 <br>
					function march() { <br>
					offset++;  <br>
					if (offset > 16) { <br>
					offset = 0;  <br>
					}  <br>
					draw();  <br>
					setTimeout(march, 20); <br>
					}  <br>
					 <br>
					march();
				</p>
				<p></p>
				<img src="../sources/examples/pic/marching-ants.png" alt="" class="center">

				<div><h2 class="section" id="M5">5. Градиенты</h2></div>

				<p>Как и в любой обычной программе рисования, можем заливать и обводить фигуры, используя линейные и радиальные градиенты. создаем объект <code>CanvasGradient</code>, используя один из следующих методов. Затем можем назначить этот объект свойствам <code>fillStyle</code> или <code>strokeStyle</code>.</p>
				<p><code>createLinearGradient (x1, y1, x2, y2)</code> - Создает объект линейного градиента с начальной точкой <code>(x1, y1)</code> и конечной точкой <code>(x2, y2)</code>.</p>
				<p><code>createRadialGradient (x1, y1, r1, x2, y2, r2)</code> - Создает радиальный градиент. Параметры представляют две окружности, одна с центром в <code>(x1, y1)</code> и радиусом <code>r1</code>, а другая с центром в <code>(x2, y2)</code> с радиусом <code>r2</code>.</p>
				<p class="code">
					var lineargradient = ctx.createLinearGradient(0, 0, 150, 150); <br>
					var radialgradient = ctx.createRadialGradient(75, 75, 0, 75, 75, 100);
				</p>
				<p>Создав объект <code>CanvasGradient</code>, можем назначить ему цвета с помощью метода <code>addColorStop ()</code>.</p>
				<p><code>gradient.addColorStop</code> (положение, цвет) - Создает новую цветовую точку для объекта градиента. Положение представляет собой число от 0,0 до 1,0 и определяет относительное положение цвета в градиенте, а аргумент цвета должен быть строкой, представляющей CSS <code>color</code>, указывающей цвет, которого должен достичь градиент при этом смещении в переходе.</p>
				<p>Вы можете добавить к градиенту столько точек цвета, сколько вам нужно. Ниже представлен очень простой линейный градиент от белого к черному.</p>
				<p class="code">
					var lineargradient = ctx.createLinearGradient(0,0,150,150); <br>
					lineargradient.addColorStop(0, 'white'); <br>
					lineargradient.addColorStop(1, 'black');
				</p>
				<p class="subsection">Пример <code>createLinearGradient</code></p>
				<p>В этом примере создадим два разных градиента. Как вы можете видеть здесь, свойства <code>strokeStyle</code> и <code>fillStyle</code> могут принимать объект <code>canvasGradient</code> в качестве допустимых входных данных.</p>
				<p class="code">
					// Create gradients <br>
					var lingrad = ctx.createLinearGradient(0,0,0,150); <br>
					lingrad.addColorStop(0, '#00ABEB'); <br>
					lingrad.addColorStop(0.5, '#fff'); <br>
					lingrad.addColorStop(0.5, '#26C000'); <br>
					lingrad.addColorStop(1, '#fff'); <br>
					 <br>
					var lingrad2 = ctx.createLinearGradient(0,50,0,95); <br>
					lingrad2.addColorStop(0.5, '#000'); <br>
					lingrad2.addColorStop(1, 'rgba(0,0,0,0)'); <br>
					 <br>
					// assign gradients to fill and stroke styles <br>
					ctx.fillStyle = lingrad; <br>
					ctx.strokeStyle = lingrad2; <br>
					 <br>
					// draw shapes <br>
					ctx.fillRect(10,10,130,130); <br>
					ctx.strokeRect(50,50,50,50);
				</p>
				<p>Первое - это фоновый градиент. Как видите, присвоили два цвета одной позиции. Это делается для очень резких переходов цвета - в данном случае от белого к зеленому. Обычно не имеет значения, в каком порядке вы определяете опорную точку, но в этом случае это существенно. Если вы сохраните функции в том порядке, в котором они должны отображаться, это не будет проблемой.</p>
				<p>Во втором градиенте не назначали начальный цвет (в позиции 0.0), поскольку это не было строго необходимо, потому что он автоматически принимает цвет следующей начальной точки градиента. Следовательно, присвоение черного цвета в позиции 0.5 автоматически делает градиент от начала до этой опорной точки.</p>
				<img src="../sources/examples/pic/gradient.png" alt="" class="center">
				<p class="subsection">Пример <code>createRadialGradient</code></p>
				<p>В этом примере определим четыре разных радиальных градиента. Поскольку у нас есть контроль над начальной и конечной точками градиента, можем добиться более сложных эффектов, чем обычно в «классических» радиальных градиентах, которые видим, например, в Photoshop (то есть градиент с одним центром точка, в которой градиент расширяется наружу в форме круга).</p>
				<p class="code">
					// Create gradients <br>
					var radgrad = ctx.createRadialGradient(45,45,10,52,50,30); <br>
					radgrad.addColorStop(0, '#A7D30C'); <br>
					radgrad.addColorStop(0.9, '#019F62'); <br>
					radgrad.addColorStop(1, 'rgba(1,159,98,0)'); <br>
					 <br>
					var radgrad2 = ctx.createRadialGradient(105,105,20,112,120,50); <br>
					radgrad2.addColorStop(0, '#FF5F98'); <br>
					radgrad2.addColorStop(0.75, '#FF0188'); <br>
					radgrad2.addColorStop(1, 'rgba(255,1,136,0)'); <br>
					 <br>
					var radgrad3 = ctx.createRadialGradient(95,15,15,102,20,40); <br>
					radgrad3.addColorStop(0, '#00C9FF'); <br>
					radgrad3.addColorStop(0.8, '#00B5E2'); <br>
					radgrad3.addColorStop(1, 'rgba(0,201,255,0)'); <br>
					 <br>
					var radgrad4 = ctx.createRadialGradient(0,150,50,0,140,90); <br>
					radgrad4.addColorStop(0, '#F4F201'); <br>
					radgrad4.addColorStop(0.8, '#E4C700'); <br>
					radgrad4.addColorStop(1, 'rgba(228,199,0,0)'); <br>
					 <br>
					// draw shapes <br>
					ctx.fillStyle = radgrad4; <br>
					ctx.fillRect(0,0,150,150); <br>
					ctx.fillStyle = radgrad3; <br>
					ctx.fillRect(0,0,150,150); <br>
					ctx.fillStyle = radgrad2; <br>
					ctx.fillRect(0,0,150,150); <br>
					ctx.fillStyle = radgrad; <br>
					ctx.fillRect(0,0,150,150);
				</p>
				<p>В этом случае немного сместили начальную точку от конечной точки, чтобы получить сферический 3D-эффект. Лучше не допускать перекрытия внутреннего и внешнего кругов, поскольку это приводит к странным эффектам, которые трудно предсказать.</p>
				<p>Последняя точка цвета в каждом из четырех градиентов использует полностью прозрачный цвет. Если вы хотите получить приятный переход от этой точки к предыдущей, оба цвета должны быть одинаковыми. Это не очень очевидно из кода, потому что в качестве демонстрации используются два разных метода цвета CSS, но в первом градиенте <code>#019F62 = rgba (1,159,98,1)</code>.</p>
				<img src="../sources/examples/pic/gradient_balls.png" alt="" class="center">

				<div><h2 class="section" id="M6">6. Шаблоны</h2></div>

				<p>В одном из предыдущих примеров использовали несколько циклов, чтобы создать шаблон из повторяющихся изображений. Однако, есть более простой способ сделать подобное - метод createPattern().</p>
				<p><code>createPattern(image, type)</code> - Создает и возвращает новый canvas объект - шаблон <code>(pattern)</code>. <code>image - CanvasImageSource</code> (то есть <code>HTMLImageElement</code>, другой холст, элемент &lt;video&gt; или подобный  объект. <code>type</code> - строка, указывающая, как использовать <code>image</code>.</p>
				<p>Тип указывает, как использовать <code>image</code> для создания шаблона и должен быть одним из следующих значений:</p>
				<ul>
					<li><code>repeat</code> - Повторяет изображение в вертикальном и горизонтальном направлениях.</li>
					<li><code>repeat-x</code> - Повторяет изображение по горизонтали, но не по вертикали.</li>
					<li><code>repeat-y</code> - Повторяет изображение по вертикали, но не по горизонтали.</li>
					<li><code>no-repeat</code> - Не повторяет изображение. Используется только один раз.</li>
				</ul>
				<p>Мы используем этот метод, чтобы создать <code>CanvasPattern</code> объект, который очень похож на методы градиента, рассмотренные ранее. Как только создали шаблон, можем назначить ему свойства <code>fillStyle</code> или <code>strokeStyle</code>. Например:</p>
				<p class="code">
					var img = new Image(); <br>
					img.src = 'someimage.png'; <br>
					var ptrn = ctx.createPattern(img,'repeat');
				</p>
				<p class="note">По аналогии с методом <code>drawImage()</code>, вы должны убедиться, что изображение, которое вы используете, загружено до вызова этого метода. Иначе шаблон может быть отрисован некорректно.</p>
				<p class="subsection">Пример <code>createPattern</code></p>
				<p>В этом последнем примере создадим шаблон, который будет назначен свойству <code>fillStyle</code>. Единственное, что стоит отметить, - это использование обработчика загрузки образа. Это необходимо для того, чтобы изображение было загружено до того, как оно будет назначено шаблону.</p>
				<p class="code">
					// create new image object to use as pattern <br>
					var img = new Image(); <br>
					img.src = 'https://mdn.mozillademos.org/files/222/Canvas_createpattern.png'; <br>
					img.onload = function(){ <br>
					 <br>
					// create pattern <br>
					var ptrn = ctx.createPattern(img,'repeat'); <br>
					ctx.fillStyle = ptrn; <br>
					ctx.fillRect(0,0,150,150); <br>
					 <br>
					}
				</p>
				<img src="../sources/examples/pic/createPattern.png" alt="" class="center">

				<h2 id="practic" class="practic">Практика</h2>

				<p class="practictext">Цель работы: Кастомизация фигур на полотне, работа с текстом, изучение градиента.</p>
				<h2 class="section">Задание к лабораторной работе №3:</h2>
				<p class="subsection">Задание №1:</p>
				<ul  class="practictodo">
					<li>
						Нарисуйте сетку из окружностей 12*12, цвета их очертаний должны плавно переливаться, оттенки должны быть похожи на палитру графического редактора. Пример с квадратами:
						<img src="../sources/examples/pic/colors.png" alt="" class="center practicpic">
					</li>
				</ul>
				<p class="subsection">Задание №2:</p>
				<p>При каждом клике мышью внутри <code>canvas</code> рисуется линия от начальной координаты до местоположения клика, начальной координатой считается <code>(0,0)</code>.</p>
				<iframe class="exframe" src="../sources/examples/frames/lab3_example.html"></iframe>
				<ul class="practictodo">
					<li>Создайте сами подобный canvas;</li>
					<li>Задайте линии градиентный цвет, прозрачность;</li>
					<li>Измените стиль линии;</li>
					<li>Добавьте кнопку, которая будет очищать canvas.</li>
				</ul>
				<p class="subsection">Задание №3:</p>
				<p>Скопируйте получившийся <code>canvas</code> и модифицируйте его:</p>
				<ul class="practictodo">
					<li>Рисование должно срабатывать на каждое движение мыши внутри canvas;</li>
					<li>Теперь модифицируйте задачу таким образом, чтобы рисование происходило при удержании клавиши мыши, при каждом движении мышью.</li>
					<li>Добавьте опцию изменения оттенка градиента линии.</li>
				</ul>


				<h2 class="section">Отчет по лабораторной работе должен содержать:</h2>

				<ul class="practictodo">
					<li>Скриншоты и описание выполнения лабораторной работы попунктно;</li>
					<li>Полный скриншот получившейся веб-страницы;</li>
					<li>HTML, CSS и JavaScript код с необходимыми объяснениями.</li>
				</ul>
				<p class="gotop"><a href="#header">Вернуться в начало</a></p>
			</div>
		</div>
	</div>

	<div class="footer">
		<div class="container">
			<div class="row justify-content-between">
				<div class="col-12 col-sm-auto">
					Dnipro National University |  Laboratory Workshop &copy; 2020
				</div>
				<div class="col-12 col-sm-auto">
					Designed by Zymeth
				</div>
			</div>
		</div>
	</div>

	
	<script src="../sources/js/classie.js"></script>
	<script src="../sources/js/gnmenu.js"></script>
	<script src="../sources/js/example.js"></script>
	<script src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/6859/tween.min_1.js'></script>
  
  
<script src="https://cpwebassets.codepen.io/assets/common/stopExecutionOnTimeout-157cd5b220a5c80d4ff8e0e70ac069bffd87a61252088146915e8726e5d9f147.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.0/zepto.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r11/Stats.js"></script>
<script src="../sources/js/canvasstars.js"></script>
	<script>
		new gnMenu(document.getElementById('gn-menu'));
	</script>


</body>
</html>