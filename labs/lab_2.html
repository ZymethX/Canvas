<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<title>Лабораторная работа 2</title>

	<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/5.0.0-alpha2/css/bootstrap.min.css" integrity="sha384-DhY6onE6f3zzKbjUPRc2hOzGAdEf4/Dz+WJwBvEYL/lkkIsI3ihufq9hk9K4lVoK" crossorigin="anonymous">

	<link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
	<link rel="stylesheet" type="text/css" href="../sources/css/normalize.css">
	<link rel="stylesheet" type="text/css" href="../sources/css/main.css">
	<link rel="stylesheet" type="text/css" href="../sources/css/tables.css">
	<link rel="stylesheet" type="text/css" href="../sources/css/tabs.css">
	<link rel="stylesheet" type="text/css" href="../sources/css/component.css">
	<link rel="stylesheet" type="text/css" href="../sources/css/example.css">

	<link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Cardo" rel="stylesheet">

	<script src="../sources/js/modernizr.custom.js"></script>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

</head>
<body>
	<div class="box">
		<ul id="gn-menu" class="gn-menu-main">
			<li class="gn-trigger">
				<a class="gn-icon gn-icon-menu"><span>Menu</span></a>
				<nav class="gn-menu-wrapper">
					<div class="tabs">
						<input type="radio" name="tab-btn" id="tab-btn-1" value="" checked>
						<label for="tab-btn-1">Меню</label>
						<input type="radio" name="tab-btn" id="tab-btn-2" value="">
						<label for="tab-btn-2">Лабы</label>

						<div id="content-1">
							<div class="gn-scroller">
								<ul class="gn-menu">
									<li><a href="#header"><span>1</span>Рисование контуров</a>
									<li><a href="#M2"><span>2</span>Рисование треугольников</a>
									<li><a href="#M3"><span>3</span>Дуги</a>
									<li><a href="#M4"><span>4</span>Безье и квадратичные кривые</a>
									<li><a href="#M5"><span>5</span>Создание комбинаций</a>
									<li><a href="#M6"><span>6</span>Path2D объекты</a>
									<li><a href="#practic"><span>-</span>Практика</a>
									
								</ul>
							</div>
						</div>

						<div id="content-2">
							<div class="gn-scroller">
								<ul class="gn-menu">
									<li><a href="lab_1.html"><span>1</span>Основы canvas</a></li>
									<li><a href="lab_2.html"><span>2</span>Создание различных фигур</a></li>
									<li><a href="lab_3.html"><span>3</span>Стили и цвета</a></li>
									<li><a href="lab_4.html"><span>4</span>Изображения и текст</a></li>
									<li><a href="lab_5.html"><span>5</span>Трансформации</a></li>
									<li><a href="lab_6.html"><span>6</span>Анимации</a></li>
								</ul>
							</div>
						</div>
					</div>
					<!-- /gn-scroller -->
				</nav>
			</li>

			<div class="container-fluid">
				<div class="row justify-content-end">
					<div class="col-12 col-sm-auto ml-sm-auto"><img class="logo" src="../sources/images/logo.png"></div>
					<div class="col-1 col-sm-auto ml-sm-auto d-none d-sm-block"><a href="#header" class="up"><i class="fa fa-chevron-circle-up" aria-hidden="true"></i> Вверх</a></div>
				</div>
			</div>
		</ul>

		<header id="header">
			<h1>Лабораторная работа 2<span>Моделирование различных фигур заданных математическими формулами</span></h1>
		</header>
	</div><!-- /box -->

	<div class="container">
		<div class="row">
			<div class="content col-12">

				<div><h2 class="section" id="M1">1. Рисование контуров</h2></div>

				<p>Примитивные фигуры создаются контурами. Контур - это набор точек, которые, соединяясь в отрезки линий, могут образовывать различные фигуры, изогнутые или нет, разной ширины и разного цвета. Контур (или субконтур) может быть закрытым.</p>

				<div class="center"><iframe src="../sources/examples/frames/l2_main_canvas.html" class="iframemain"></iframe></div>
				<p class="cuptionexample">Пример использования <code>canvas</code> для оформления фона вашего сайта</p>

				<p>Создание фигур используя контуры происходит в несколько важных шагов:</p>
				<ul>
					<li>Сначала вы создаете контур.</li>
					<li>Затем, используя команды рисования, рисуете контур.</li>
					<li>Потом закрываете контур.</li>
					<li>Созданный контур вы можете обвести или залить для его отображения.</li>
				</ul>
				<p>Здесь приведены функции, которые можно использовать в описанных шагах:</p>
				<ul>
					<li><code>beginPath()</code> - cоздает новый контур. После создания используется в дальнейшем командами рисования при построении контуров.</li>
					<li><code>Path</code> методы - для установки различных контуров объекта.</li>
					<li><code>closePath()</code> - закрывает контур, так что будущие команды рисования вновь направлены контекст.</li>
					<li><code>stroke()</code> - рисует фигуру с внешней обводкой.</li>
					<li><code>fill()</code> - рисует фигуру с заливкой внутренней области.</li>
				</ul>
				<p>Первый шаг создания контура заключается в вызове функции <code>beginPath()</code>. Внутри содержатся контуры в виде набора суб-контуров (линии, дуги и др.), которые вместе образуют форму фигуры. Каждый вызов этого метода очищает набор, и мы можем начинать рисовать новые фигуры.</p>
				<p class="note">Если текущий контур пуст (например, как после вызова <code>beginPath()</code> или на вновь созданном <code>canvas</code>), первой командой построения контура всегда является функция  <code>moveTo()</code>. Поэтому мы всегда можем установить начальную позицию рисования контура после перезагрузки.</p>
				<p>Вторым шагом является вызов методов, определяемых видом контура, который нужно нарисовать. Их мы рассмотрим позднее.</p>
				<p>Третий и необязательный шаг - это вызов <code>closePath()</code>. Этот метод пытается закрыть фигуру, рисуя прямую линию из текущей точки в начальную. Если фигура была уже закрыта или является просто точкой, то функция ничего не делает.</p>
				<p class="note">Когда вы вызываете <code>fill()</code>, то каждая открытая фигура закрывается автоматически, так что вы можете не использовать <code>closePath()</code>. Это обстоятельство не имеет место в случае вызова <code>stroke()</code>.</p>

				<div><h2 class="section" id="M2">2. Рисование треугольников</h2></div>

				<p>Например, код для рисования треугольника будет выглядеть как-то так:</p>
				<p class="code">
					function draw() { <br>
					var canvas = document.getElementById('canvas'); <br>
					if (canvas.getContext){ <br>
					var ctx = canvas.getContext('2d'); <br>
 					<br>
					ctx.beginPath(); <br>
					ctx.moveTo(75,50); <br>
					ctx.lineTo(100,75); <br>
					ctx.lineTo(100,25); <br>
					ctx.fill(); <br>
					} <br>
					}
				</p>
				<p>Результат выглядит так:</p>
				<img src="../sources/examples/pic/triangle.png" alt="" class="center">
				<p>Теперь давайте разберемся подробнее как это работает.</p>
				<p>Одна очень полезная функция, которая ничего не рисует, но связана по смыслу с вышеописанными функциями  - это <code>moveTo()</code>. Вы можете представить это как отрыв (подъем) пера от бумаги и его перемещение в другое место.</p>
				<p><code>moveTo(x, y)</code> - перемещает перо в точку с координатами <code>x</code> и <code>y</code>.</p>
				<p>При инициализации canvas или при вызове<code> beginPath()</code>, вы захотите использовать функцию <code>moveTo()</code> для перемещения в точку начала рисования. Можно использовать <code>moveTo()</code> и для рисования несвязанного(незакрытого) контура.</p>
				<p>Важность путей также состоит в том, что они позволяют заполнять цветом фигуры. Например, нарисуем красными линиями треугольник посредством следующего кода:</p>
				<p class="code">
					context.moveTo(250,50); <br>
					context.lineTo(50,250); <br>
					context.lineTo(450,250); <br>
					context.lineTo(250,50); <br>
					<br>
					context.lineWidth = 10; <br>
					context.strokeStyle = "red"; <br>
					context.stroke(); <br>
				</p>
				<p>Теперь мы хотим закрасить внутреннюю область этого треугольника, но метод <code>stroke()</code> для этой задачи не подходит. Здесь нужно закрыть текущий путь с помощью метода <code>closePath()</code>, выбрать цвет заливки, установив значение свойства <code>fillStyle</code>, а потом вызвать метод <code>fill()</code>, чтобы собственно выполнить заливку.</p>
				<p>В этом примере стоит сделать пару доводок. Первое: при закрытии пути нет надобности рисовать последний сегмент линии, т.к. вызов метода <code>closePath()</code> автоматически строит линию между последней нарисованной точкой и начальной точкой. Второе: лучше сначала выполнить заливку фигуры и только потом очертить ее контуры. В противном случае линии контура могут быть частично перекрыты заливкой.</p>
				<p>Далее приведен полный код для рисования и заливки треугольника:</p>
				<p class="code">
					context.moveTo(150,60); <br>
					context.lineTo(50,140); <br>
					context.lineTo(250,140); <br>
					context.closePath(); <br>
					 <br>
					// Заливка <br>
					context.fillStyle = "#E31B6D"; <br>
					context.fill(); <br>
					 <br>
					// Контур <br>
					context.lineWidth = 10; <br>
					context.strokeStyle = "#404040"; <br>
					context.stroke();
				</p>
				<p>Обратите внимание, что в этом примере метод <code>beginPath()</code> вызывать не нужно, путь создается автоматически. Метод <code>beginPath()</code> следует вызывать, только когда надо начать новый путь, например при изменении параметров линии или новой фигуры. Результаты выполнения кода показаны ниже:</p>
				
				<img src="../sources/examples/pic/triangle2.png" alt="" class="center">
				<p>Вершины фигур, создаваемые соединяющимися линиями, можно оформить тремя разными способами, присваивая свойству контекста <code>lineJoin</code> соответствующие значения. Значение <code>round</code> округляет вершины, значение <code>mitre</code> соединяет линии в вершине "под ус", а значение <code>bevel</code> обрезает вершины прямой линией. По умолчанию свойству <code>lineJoin</code> присвоено значение <code>mitre</code>.</p>

				<div><h2 class="section" id="M3">3. Дуги</h2></div>

				<p>Чтобы рисовать что-то более сложное, чем линии и прямоугольники, нужно изучить следующие четыре метода: <code>arc()</code>, <code>arcTo()</code>, <code>bezierCurveTo()</code> и <code>quadraticCurveTo()</code>. Все эти методы рисуют кривые линии, и хотя каждый делает это по-своему, все они требуют хотя бы небольших (а некоторые и больших) знаний математики.</p>
				<p>Изо всех этих методов самый простой — метод <code>arc()</code>, который рисует дугу. Чтобы нарисовать дугу, нужно сначала представить себе в уме полный круг, а потом решить, какую часть его окружности вы хотите рисовать:</p>
				<div class="center"><img src="../sources/examples/pic/circle2.png" alt="" class="center"></div>
				<p>Дуга выглядит достаточно простой фигурой, но чтобы полностью ее описать, требуется несколько единиц информации. Сначала нужно нарисовать воображаемый круг. Для этого надо знать координаты центра (1) и радиуса (2), который определяет размер круга. Далее следует описать длину дуги на окружности, для чего требуется угол начала дуги (3) и угол ее окончания (4). Значения углов должны быть в радианах, которые выражаются через число π. Угол всей окружности равен 2π, половины — 1π и т.д.</p>
				<p class="note">Углы в функции <code>arc()</code> измеряют в радианах, не в градусах. Для перевода градусов в радианы вы можете использовать JavaScript-выражение: <code>radians = (Math.PI/180)*degrees</code>.</p>
				<p>Собрав все необходимые данные, передаем их методу <code>arc()</code>:</p>
				<p class="code">
					// Толщина и цвет дуги <br>
					context.lineWidth = 20; <br>
					context.strokeStyle = "rgb(16,155,252)"; <br>
 					<br>
					// Создаем переменные для хранения информации о дуге <br>
					var centerX = 150; <br>
					var centerY = 200; <br>
					var radius = 100; <br>
					var startingAngle = 1.25 * Math.PI; <br>
					var endingAngle = 1.75 * Math.PI; <br>
 					<br>
					// Рисуем дугу на основе этой информации <br>
					context.arc(centerX, centerY, radius, startingAngle, endingAngle); <br>
					context.stroke();
				</p>
				<img src="../sources/examples/pic/arc.png" alt="" class="center">
				<p>Дугу можно закрыть, соединив ее концы прямой линией. Для этого нужно вызвать метод <code>closePath()</code> перед тем, как вызывать метод <code>stroke()</code>. Кстати, окружность — это та же дуга, просто с углом 2π. Рисуется окружность следующим образом:</p>
				<p class="code">
					// ... <br>
					var startingAngle = 0; <br>
					var endingAngle = 2 * Math.PI;
				</p>
				<p>Метод <code>arc()</code> нельзя применять для рисования овала (вытянутого круга). Для этого нужно использовать либо более сложные методы для рисования кривых, либо применить трансформации.</p>
				<p>Подведем итоги для <code>arc()</code>: </p>
				<p class="note"><code>arc(x, y, radius, startAngle, endAngle, anticlockwise)</code> - рисуем дугу с центром в точке <code>(x,y)</code> радиусом <code>radius</code>, начиная с угла <code>startAngle</code> и заканчивая в <code>endAngle</code> в направлении против часовой стрелки <code>anticlockwise</code> (по умолчанию по ходу движения часовой стрелки).</p>
				<p class="code">
					var ctx = document.querySelector("canvas").getContext("2d"); <br>
					ctx.fillStyle = "#D7273B";  <br>
					ctx.beginPath(); <br>
					ctx.arc(15,15,15,0,Math.PI*2,true); <br>
					ctx.closePath(); <br>
					ctx.fill(); <br>
					 <br>
					ctx.fillStyle = "#404040"; <br>
					ctx.beginPath(); <br>
					ctx.arc(50,15,15,0,Math.PI*2,true); <br>
					ctx.closePath(); <br>
					ctx.fill();
				</p>
				<p>А так будет отображаться результат кода, представленного выше:</p>
				<img src="../sources/examples/pic/circles.png" alt="" class="center">
				<p>Рассмотрим еще один пример рисования дуг, прежде, чем перейти далее.</p>
				<p>Два <code>for</code> цикла размещают дуги по столбцам и строкам. Для каждой дуги, мы начинаем новый контур, вызывая <code>beginPath()</code>. В этом коде каждый параметр дуги для большей ясности задан в виде переменной, но вам не обязательно делать так в реальных проектах.</p>
				<p>Координаты <code>x</code> и <code>y</code>  должны быть достаточно ясны. <code>radius and startAngle</code> — фиксированы. <code>endAngle</code> начинается со 180 градусов (полуокружность) в первой колонке и, увеличиваясь с шагом 90 градусов, достигает кульминации полноценной окружностью в последнем столбце.</p>
				<p>Установка параметра <code>clockwise</code> определяет результат; в первой и третьей строках рисование дуг происходит по часовой стрелке, а во второй и четвертой - против часовой стрелки. Благодаря <code>if</code>-условию верхняя половина дуг образуется с контуром, (обводкой), а нижняя половина дуг - с заливкой.</p>
				<p class="code">
					function draw() { <br>
					var canvas = document.getElementById('canvas'); <br>
					if (canvas.getContext){ <br>
					var ctx = canvas.getContext('2d'); <br>
					 <br>
					for(var i=0;i<4;i++){ <br>
					for(var j=0;j<3;j++){ <br>
					ctx.beginPath(); <br>
					var x = 25+j*50; // x coordinate <br>
					var y = 25+i*50; // y coordinate <br>
					var radius = 20; // Arc radius <br>
					var startAngle = 0; // Starting point on circle <br>
					var endAngle = Math.PI+(Math.PI*j)/2; // End point on circle <br>
					var anticlockwise = i%2==0 ? false : true; // clockwise or anticlockwise <br>
					 <br>
					ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise); <br>
					 <br>
					if (i>1){ <br>
					ctx.fill(); <br>
					} else { <br>
					ctx.stroke(); <br>
					} <br>
					} <br>
					} <br>
					} <br>
					}
				</p>
				<img src="../sources/examples/pic/arcs.png" alt="" class="center">

				<p>Метод <code>arcTo</code> принимает целых пять аргументов. Первая пара задаёт что-то вроде контрольной точки, вторая – место назначения кривой. Пятый задаёт радиус дуги. Метод создаёт скруглённый угол – линию, идущую к контрольной точке, а затем к точке назначения – и скругляет угол заданным радиусом. Метод <code>arcTo</code> рисует круглую часть, а также линию от точки старта до начала закруглённой части.</p>
				<p class="code">
					var cx = document.querySelector("canvas").getContext("2d"); <br>
					cx.beginPath(); <br>
					cx.moveTo(10, 10); <br>
					// control=(90,10) goal=(90,90) radius=20 <br>
					cx.arcTo(90, 10, 90, 90, 20); <br>
					cx.moveTo(10, 10); <br>
					// control=(90,10) goal=(90,90) radius=80 <br>
					cx.arcTo(90, 10, 90, 90, 80); <br>
					cx.stroke();
				</p>
				<p><code>arcTo</code> не рисует линию от конца закруглённой части до точки назначения, несмотря на своё название. Её можно закончить через <code>lineTo</code> с такими же координатами.</p>
				<p>Чтобы нарисовать круг, можно сделать четыре вызова <code>arcTo</code>, где каждый повёрнут относительно другого на 90 градусов. Но метод <code>arc</code> предоставляет способ проще. Он принимает пару координат центра арки, радиус и начальный и конечный углы.</p>
				<p>Подведем итоги для <code>arcTo()</code>: </p>
				<p class="note"><code>arcTo(x1, y1, x2, y2, radius)</code> - рисуем дугу с заданными контрольными точками и радиусом, соединяя эти точки прямой линией.</p>

				<div><h2 class="section" id="M4">4. Безье и квадратичные кривые</h2></div>

				<p>Следующим типом доступных контуров являются  кривые Безье, и к тому же доступны в кубическом и квадратичном вариантах. Обычно они используются при рисовании сложных составных фигур.</p>
				<p><code>quadraticCurveTo(cp1x, cp1y, x, y)</code> - рисует кривую до нужной точки. Для определения кривизны методу даётся контрольная точка <code>(cp1x, cp1y)</code> вместе с точкой назначения <code>(x, y)</code>. Представьте, что контрольная точка как бы притягивает линию, задавая кривой кривизну. Линия не проходит через контрольную точку. Вместо этого направления линии в её начальной и конечной точках будут стремиться к контрольной точке. Следующий пример иллюстрирует это:</p>
				<p class="code">
					var cx = document.querySelector("canvas").getContext("2d"); <br>
					cx.beginPath(); <br>
					cx.moveTo(10, 90); <br>
					// control=(60,10) goal=(90,90) <br>
					cx.quadraticCurveTo(60, 10, 90, 90); <br>
					cx.lineTo(60, 10); <br>
					cx.closePath(); <br>
					cx.stroke();
				</p>
				<p>Рисуем слева направо квадратичную кривую, у которой контрольная точка задана как <code>(60,10)</code>, а затем рисуем два сегмента, проходящие обратно через контрольную точку и начало линии. Результат напоминает эмблему Звёздного пути. Можно увидеть действие контрольной точки: линия, выходящая из начальной и конечной точек, начинается по направлению к контрольной точке, а затем загибается.</p>
				<p>Метод <code>bezierCurve</code> рисует схожую кривую. Вместо одной контрольной точки у неё есть две – по одной на каждый из концов кривой. Вот похожий рисунок для иллюстрации поведения такой кривой:</p>
				<p class="code">
					var cx = document.querySelector("canvas").getContext("2d"); <br>
					cx.beginPath(); <br>
					cx.moveTo(10, 90); <br>
					// control1=(10,10) control2=(90,10) goal=(50,90) <br>
					cx.bezierCurveTo(10, 10, 90, 10, 50, 90); <br>
					cx.lineTo(90, 10); <br>
					cx.lineTo(10, 10); <br>
					cx.closePath(); <br>
					cx.stroke();
				</p>
				<p>Две контрольные точки задают направления обоих концов кривой. Чем они дальше от начала или конца, тем сильнее кривая будет выпучиваться в их направлении.</p>
				<p>С этими кривыми сложновато работать – не всегда понятно, как искать контрольные точки, которые приведут к нужной вам форме. Иногда их можно вычислить, иногда приходится подбирать методом проб и ошибок.</p>
				<p>Подведем итоги:</p>
				<p><code>quadraticCurveTo(cp1x, cp1y, x, y)</code> - рисуется квадратичная кривая Безье с текущей позиции пера в конечную точку с координатами <code>x</code> и <code>y</code>, используя контрольную точку с координатами <code>cp1x</code> и <code>cp1y</code>.</p>
				<p><code>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</code> - рисуется кубическая кривая Безье с текущей позиции пера в конечную точку с координатами <code>x</code> и <code>y</code>, используя две контрольные точки с координатами <code>(cp1x, cp1y)</code> и <code>(cp2x, cp2y)</code>.</p>
				<p>Различие между ними можно увидеть на рисунке ниже. Квадратичная кривая Безье имеет стартовую и конечную точки (синие точки) и всего одну контрольную точку (красная точка), в то время как кубическая кривая Безье использует две контрольные точки.</p>
				<div class="center">
					<img src="../sources/examples/pic/curves.png" alt="" class="center">
				</div>
				<p>Параметры <code>x</code> и <code>y</code> в этих двух методах являются координатами конечной точки. <code>cp1x</code> и <code>cp1y</code> — координаты первой контрольной точки, а <code>cp2x</code> и <code>cp2y</code> — координаты второй контрольной точки.</p>
				<p>Использование квадратичных или кубических кривых Безье может быть  спорным выходом, так как в отличие от приложений векторной графики типа Adobe Illustrator, мы не имеем полной видимой обратной связи с тем, что мы делаем. Этот факт делает довольно сложным процесс рисования сложных фигур. В следующем примере многократно используются квадратичные кривые Безье для рисования речевой выноски.</p>
				<p>Кривая Безье создается следующим кодом:</p>
				<p class="code">
					// Толщина и цвет кривой <br>
					context.lineWidth = 10; <br>
					context.strokeStyle = "rgb(16,155,252)"; <br>
 					<br>
					// Устанавливаем начало кривой <br>
					context.moveTo(62, 242); <br>
 					<br>
					// Контрольные и конечная точки <br>
					var controlX_1 = 187; <br>
					var controlY_1 = 32; <br>
					var controlX_2 = 429; <br>
					var controlY_2 = 480; <br>
					var endPointX = 365; <br>
					var endPointY = 133; <br>
 					<br>
					// Рисуем кривую <br>
					context.bezierCurveTo(controlX_1, controlY_1, controlX_2, controlY_2, endPointX, endPointY); <br>
					context.stroke();
				</p>
				<img src="../sources/examples/pic/line.png" alt="" class="center">
				<p>Контур сложной фигуры часто состоит из ряда дуг и кривых, соединяющихся друг с другом. По окончанию рисования всех составляющих можно вызвать метод <code>closePath()</code>, чтобы обвести или закрасить всю фигуру.</p>
				<p class="code">
					// Quadratric curves example <br>
					ctx.beginPath(); <br>
					ctx.moveTo(75,25); <br>
					ctx.quadraticCurveTo(25,25,25,62.5); <br>
					ctx.quadraticCurveTo(25,100,50,100); <br>
					ctx.quadraticCurveTo(50,120,30,125); <br>
					ctx.quadraticCurveTo(60,120,65,100); <br>
					ctx.quadraticCurveTo(125,100,125,62.5); <br>
					ctx.quadraticCurveTo(125,25,75,25); <br>
					ctx.stroke();
				</p>
				<img src="../sources/examples/pic/speech.png" alt="" class="center">
				<p>В этом примере нарисовано сердце с использованием кубических кривых Безье.</p>
				<p class="code">
					// Cubic curves example <br>
					ctx.beginPath(); <br>
					ctx.moveTo(75,40); <br>
					ctx.bezierCurveTo(75,37,70,25,50,25); <br>
					ctx.bezierCurveTo(20,25,20,62.5,20,62.5); <br>
					ctx.bezierCurveTo(20,80,40,102,75,120); <br>
					ctx.bezierCurveTo(110,102,130,80,130,62.5); <br>
					ctx.bezierCurveTo(130,62.5,130,25,100,25); <br>
					ctx.bezierCurveTo(85,25,75,37,75,40); <br>
					ctx.fill();
				</p>
				<img src="../sources/examples/pic/heart.png" alt="" class="center">

				<div><h2 class="section" id="M5">5. Создание комбинаций</h2></div>

				<p>До сих пор, в каждом примере использовался только один тип функции контуров для каждой фигуры. Однако, нет никаких ограничений на количество или типы контуров, которые вы можете использовать для создания фигур. Давайте в этом примере объединим все вышеперечисленные функции контуров, чтобы создать набор очень известных игровых персонажей.</p>
				<p class="code">
					function draw() { <br>
					var canvas = document.getElementById('canvas'); <br>
					if (canvas.getContext){ <br>
					var ctx = canvas.getContext('2d'); <br>
					 <br>
					roundedRect(ctx,12,12,150,150,15); <br>
					roundedRect(ctx,19,19,150,150,9); <br>
					roundedRect(ctx,53,53,49,33,10); <br>
					roundedRect(ctx,53,119,49,16,6); <br>
					roundedRect(ctx,135,53,49,33,10); <br>
					roundedRect(ctx,135,119,25,49,10); <br>
					 <br>
					ctx.beginPath(); <br>
					ctx.arc(37,37,13,Math.PI/7,-Math.PI/7,false); <br>
					ctx.lineTo(31,37); <br>
					ctx.fill(); <br>
					 <br>
					for(var i=0;i<8;i++){ <br>
					ctx.fillRect(51+i*16,35,4,4); <br>
					} <br>
					 <br>
					for(i=0;i<6;i++){ <br>
					ctx.fillRect(115,51+i*16,4,4); <br>
					} <br>
					 <br>
					for(i=0;i<8;i++){ <br>
					ctx.fillRect(51+i*16,99,4,4); <br>
					} <br>
					 <br>
					ctx.beginPath(); <br>
					ctx.moveTo(83,116); <br>
					ctx.lineTo(83,102); <br>
					ctx.bezierCurveTo(83,94,89,88,97,88); <br>
					ctx.bezierCurveTo(105,88,111,94,111,102); <br>
					ctx.lineTo(111,116); <br>
					ctx.lineTo(106.333,111.333); <br>
					ctx.lineTo(101.666,116); <br>
					ctx.lineTo(97,111.333); <br>
					ctx.lineTo(92.333,116); <br>
					ctx.lineTo(87.666,111.333); <br>
					ctx.lineTo(83,116); <br>
					ctx.fill(); <br>
					 <br>
					ctx.fillStyle = "white"; <br>
					ctx.beginPath(); <br>
					ctx.moveTo(91,96); <br>
					ctx.bezierCurveTo(88,96,87,99,87,101); <br>
					ctx.bezierCurveTo(87,103,88,106,91,106); <br>
					ctx.bezierCurveTo(94,106,95,103,95,101); <br>
					ctx.bezierCurveTo(95,99,94,96,91,96); <br>
					ctx.moveTo(103,96); <br>
					ctx.bezierCurveTo(100,96,99,99,99,101); <br>
					ctx.bezierCurveTo(99,103,100,106,103,106); <br>
					ctx.bezierCurveTo(106,106,107,103,107,101); <br>
					ctx.bezierCurveTo(107,99,106,96,103,96); <br>
					ctx.fill(); <br>
					 <br>
					ctx.fillStyle = "black"; <br>
					ctx.beginPath(); <br>
					ctx.arc(101,102,2,0,Math.PI*2,true); <br>
					ctx.fill(); <br>
					 <br>
					ctx.beginPath(); <br>
					ctx.arc(89,102,2,0,Math.PI*2,true); <br>
					ctx.fill(); <br>
					} <br>
					} <br>
					 <br>
					// A utility function to draw a rectangle with rounded corners. <br>
					 <br>
					function roundedRect(ctx,x,y,width,height,radius){ <br>
					ctx.beginPath(); <br>
					ctx.moveTo(x,y+radius); <br>
					ctx.lineTo(x,y+height-radius); <br>
					ctx.quadraticCurveTo(x,y+height,x+radius,y+height); <br>
					ctx.lineTo(x+width-radius,y+height); <br>
					ctx.quadraticCurveTo(x+width,y+height,x+width,y+height-radius); <br>
					ctx.lineTo(x+width,y+radius); <br>
					ctx.quadraticCurveTo(x+width,y,x+width-radius,y); <br>
					ctx.lineTo(x+radius,y); <br>
					ctx.quadraticCurveTo(x,y,x,y+radius); <br>
					ctx.stroke(); <br>
					}
				</p>
				<p>Конечное изображение выглядит так:</p>
				<img src="../sources/examples/pic/pacman.png" alt="" class="center">
				<p>Наиболее важные вещи, которые следует отметить, это использование свойства <code>fillStyle</code> в контексте рисования и использование функции утилиты (в данном случае <code>roundedRect()</code>). Использование функций утилиты для битов чертежа часто может быть очень полезным и сократить количество необходимого кода, а также его сложность.</p>

				<div><h2 class="section" id="M6">6. Path2D объекты</h2></div>

				<p>Как мы видели в последнем примере, есть серия путей и команд для рисования объектов на вашем холсте. Чтобы упростить код и повысить производительность, объект <code>Path2D</code>, доступный в последних версиях браузеров, позволяет вам кэшировать или записывать эти команды рисования. Вы можете быстро запускать свои пути. Давайте посмотрим, как мы можем построить объект <code>Path2D</code> :</p>
				<p><code>Path2D()</code> - конструктор <code>Path2D()</code> возвращает вновь созданный объект <code>Path2D</code>  необязательно с другим путем в качестве аргумента (создает копию) или необязательно со строкой, состоящей из данных пути <code>SVG path</code>.</p>
				<p class="code">
					new Path2D();     // пустой path объект <br>
					new Path2D(path); // копирование из другого path <br>
					new Path2D(d);    // path из SVG
				</p>
				<p>Все методы <code>path</code>, такие как <code>moveTo</code>, <code>rect</code>, <code>arc</code> или <code>quadraticCurveTo</code> итп, которые мы уже знаем, доступны для объектов <code>Path2D</code>.</p>
				<p>API <code>Path2D</code> также добавляет способ комбинирования путей с использованием метода <code>addPath</code>. Это может быть полезно, если вы хотите, например, создавать объекты из нескольких компонентов.</p>
				<p><code>Path2D.addPath(path [, transform])</code> - добавляет путь к текущему пути с необязательной матрицей преобразования.</p>
				<p>В этом примере мы создаем прямоугольник и круг. Оба они сохраняются как объект <code>Path2D</code>, поэтому они доступны для последующего использования. С новым API <code>Path2D</code> несколько методов были обновлены, чтобы при необходимости принять объект <code>Path2D</code> для использования вместо текущего пути. Здесь <code>stroke</code> и <code>fill</code> используются с аргументом пути, например, для рисования обоих объектов на холст.</p>
				<p class="code">
					var rectangle = new Path2D(); <br>
					rectangle.rect(10, 10, 50, 50); <br>
 					<br>
					var circle = new Path2D(); <br>
					circle.moveTo(125, 35); <br>
					circle.arc(100, 35, 25, 0, 2 * Math.PI); <br>
 					<br>
					ctx.stroke(rectangle); <br>
					ctx.fill(circle);
				</p>
				<p>Результат:</p>
				<img src="../sources/examples/pic/square_circle.png" alt="" class="center">

				<h2 id="practic" class="practic">Практика</h2>

				<p class="practictext">Цель работы: Изучение возможностей canvas, рисование сложных фигур, создание комбинаций.</p>
				<h2 class="section">Задание к лабораторной работе №2:</h2>

				<p class="subsection">Задание №1:</p>
				<ul class="practictodo">
					<li>
						Создайте веб-страницу с canvas в котором нарисуйте:
					</li>
					<ul>
						<li>Полупрозрачную черную трапецию;</li>
						<li>Зеленый ромб;</li>
						<li>Зигзаг;</li>
						<li>Спираль из 10-20 витков;</li>
						<li>Красную звезду.</li>
						<li>Смайлик.</li>
					</ul>
				</ul>
				<p class="subsection">Задание №2:</p>
				<ul class="practictodo">
					<li>
						Обратите внимание на пункт №5 Создание комбинаций, возьмите оттуда код, и на его основе доработайте уровень из Pacman до конца.
					</li>
				</ul>

				<h2 class="section">Отчет по лабораторной работе должен содержать:</h2>

				<ul class="practictodo">
					<li>Скриншоты и описание выполнения лабораторной работы попунктно;</li>
					<li>Полный скриншот получившейся веб-страницы;</li>
					<li>HTML, CSS и JavaScript код с необходимыми объяснениями.</li>
				</ul>

				<p class="gotop"><a href="#header">Вернуться в начало</a></p>
			</div>
		</div>
	</div>

	<div class="footer">
		<div class="container">
			<div class="row justify-content-between">
				<div class="col-12 col-sm-auto">
					Dnipro National University |  Laboratory Workshop &copy; 2020
				</div>
				<div class="col-12 col-sm-auto">
					Designed by Zymeth
				</div>
			</div>
		</div>
	</div>

	<script src="../sources/js/canvascircles.js"></script>
	<script src="../sources/js/classie.js"></script>
	<script src="../sources/js/gnmenu.js"></script>
	<script src="../sources/js/example.js"></script>
	<script src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/6859/tween.min_1.js'></script>

	<script>
		new gnMenu(document.getElementById('gn-menu'));
	</script>

</body>
</html>